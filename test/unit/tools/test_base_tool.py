import os
import json
import unittest
from pathlib import Path

from src.agent.tools.base import Tool


class TestBaseTool(unittest.TestCase):
    """Tests the Tool class in `src.agent.tools.base`.

    The implemented tests must answer the following questions:
    1. [x] `load_tool`: create Tool object from json file

        - what happens if json schema is wrong?
        - what happens if the content of json fields is empty?
        - what happens if the provided path doesn't exist?

    2. [x] `run`: executes a command

        - what happens if invalid input is provided? (not the string command)
        - what happens if command execution fails?
        - what happens if a command never exits its execution?
            > some commands will run for long (ex. nmap, hashcat);
            > inspection should be implemented (...).
    """
    SCHEMA_PATH = Path(Path(__file__).parent / 'base_tool_schemas')
    CMDS_PATH = Path(Path(__file__).parent / 'cmd_cases.json')
    BASE_PATH = Path('tools_settings') if Path('tools_settings').exists() \
        else Path(Path(__file__).parent.parent.parent.parent / 'tools_settings')  # awful

    @classmethod
    def setUpClass(cls):
        print('\n\n# test_base_tool.py\n')
        print('## Setup Resources')
        WRONG_SCHEMAS = {
            "wrong_type": "",
            "empty_schema": {},
            "missing_keys": {"name": "test"},
            "more_keys": {"name": "test", "tool_description": "tool", "args_description": "", "use_case": "use_case","sum_else": ""},
            "wrong_schema": {"1": 1, "2": 2, "3": 3, "4": 4},
            "empty_field": {"name": "test", "tool_description": "tool", "args_description": "", "use_case": ""},
            "nested_schema": [{"name": "test"}],
        }

        CMDS_CASES = {
            "invalid_type": 1,
            "empty_input": "",
            "single_arg": "ls",
            "multi_arg": "ls -la",
            "wrong_arg": "ls --invalid"
        }

        print(f'--- Creating schema DIR {cls.SCHEMA_PATH}')
        cls.SCHEMA_PATH.mkdir(parents=True, exist_ok=True)
        for name, schema in WRONG_SCHEMAS.items():
            # print(f'--- Creating schema JSON: {name}')
            path = str(Path(cls.SCHEMA_PATH / name))
            with open(f'{path}.json', 'w+') as fp:
                json.dump(schema, fp)

        print(f'--- Creating run test cases {cls.CMDS_PATH}')
        with open(cls.CMDS_PATH, 'w+') as fp:
            json.dump(CMDS_CASES, fp)

    @classmethod
    def tearDownClass(cls):
        print('\n\n## Clean Resources')
        try:
            for path in cls.SCHEMA_PATH.iterdir():
                os.remove(str(path))
            os.rmdir(str(cls.SCHEMA_PATH))
            os.remove(str(cls.CMDS_PATH))

            print(f"Setup files removed successfully")
        except OSError as error:
            print(error)
            print(f"Failed to remove one of the following:\n{cls.SCHEMA_PATH}\n{cls.CMDS_PATH}")

    def test_load_tool(self):
        print()
        EXPECTED = {
            "wrong_type": TypeError,
            "empty_schema": ValueError,
            "missing_keys": ValueError,
            "more_keys": ValueError,
            "wrong_schema": ValueError,
            "empty_field": ValueError,
            "nested_schema": TypeError,
        }

        try:
            for path in Path(f'./{self.SCHEMA_PATH}').iterdir():
                expected = EXPECTED[path.name.split('.')[0]]
                print(f'Loading {path.name}; expected: {str(expected)}')
                self.assertRaises(expected, Tool.load_tool, str(path))
        except FileNotFoundError as err:
            print(err)
            ls = "\n".join(os.listdir(os.curdir))
            print(f'Current dir: {os.curdir}\n{ls}')

    def test_run_tool(self):
        print()
        EXPECTED = {
            "invalid_type": TypeError,
            "empty_input": ValueError,
            "single_arg": True,
            "multi_arg": True,
            "wrong_arg": True
        }

        with open(self.CMDS_PATH, 'r') as fp:
            test_case: dict = json.load(fp)
            for case, cmd_input in test_case.items():
                print(f'Executing case {case}: {cmd_input}')
                if EXPECTED[case] is True:
                    self.assertIsNotNone(Tool.run(cmd_input), f"Empty output for {cmd_input}")
                else:
                    self.assertRaises(EXPECTED[case], Tool.run, cmd_input)

    def test_load_tool_from_generated(self):
        """The tool documentations in `tools_settings` are LLM generated, to ensure
        the correct JSON format is generated every time a new tool is added this
        test verifies the tool can be correctly loaded."""
        try:
            for path in Path(self.BASE_PATH).iterdir():
                if path.is_file() and path.suffix == '.json':
                    Tool.load_tool(str(path))
        except Exception as err:
            self.fail(f'Tool Integration failed.\n{err}')


if __name__ == "__main__":
    unittest.main()
